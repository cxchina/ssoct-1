// ============================================================================
// Copyright (c) 2010 by Terasic Technologies Inc. 
// ============================================================================
//
// Permission:
//
//   Terasic grants permission to use and modify this code for use
//   in synthesis for all Terasic Development Boards and Altera Development 
//   Kits made by Terasic.  Other use of this code, including the selling 
//   ,duplication, or modification of any portion is strictly prohibited.
//
// Disclaimer:
//
//   This VHDL/Verilog or C/C++ source code is intended as a design reference
//   which illustrates how these types of functions can be implemented.
//   It is the user's responsibility to verify their design for
//   consistency and functionality through the use of formal
//   verification methods.  Terasic provides no warranty regarding the use 
//   or functionality of this code.
//
// ============================================================================
//           
//                     Terasic Technologies Inc
//                     356 Fu-Shin E. Rd Sec. 1. JhuBei City,
//                     HsinChu County, Taiwan
//                     302
//
//                     web: http://www.terasic.com/
//                     email: support@terasic.com
//
// ============================================================================
// Major Functions/Design Description:
//
//   DE4 Development Board + DCC(AD/DA Data Conversion Card) demo
//
//   user interface define
//     LED :
//        LED[0] 	  --> PLL locked indicator.					Light = Locked.
//        LED[1] 	  --> ADC DFS(Data Format Select) indicator.
//        LED[2] 	  --> ADC DCS(Duty Cycle Stabilizer Select) indicator.
//        LED[3] 	  --> ADC Out-of-Range indicator.			Light = Out-of-Range.
//        LED[4] 	  --> 1MHz NCO output disable indicator.	Light = disable.
//        LED[5] 	  --> 10MHz NCO output disable indicator.	Light = disable.
//        LED[6] 	  --> Channel A or B indicator.				Light = channel B select.
//        LED[7] 	  --> Heartbeat.
//      SLIDE_SW : 
//        SLIDE_SW[0] --> ADC DFS(Data Format Select)
//        SLIDE_SW[1] --> ADC DCS(Duty Cycle Stabilizer Select)
//        SLIDE_SW[2] --> Not use
//        SLIDE_SW[3] --> Channel A or B select, High is select channel B.
//      BUTTON : 
//        BUTTON[0]   --> 1MHz NCO output disable
//        BUTTON[1]   --> 10MHz NCO output disable
//        BUTTON[2]   --> Not use
//        BUTTON[3]   --> Not use
//
// ============================================================================
// Revision History:
// ============================================================================
//   Ver.: |Author:   |Mod. Date:    |Changes Made:
//   V1.0  |EricChen  |10/07/05      |
// ============================================================================


//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
`default_nettype none
module DE4_DCC_HSMB(

	//////// CLOCK //////////
	GCLKIN,				// 50 kHz A-line (sweep) Trigger
	GCLKOUT_FPGA,
	OSC_50_BANK2,
	OSC_50_BANK3,
	OSC_50_BANK4,
	OSC_50_BANK5,
	OSC_50_BANK6,
	OSC_50_BANK7,
	PLL_CLKIN_p,

	//////// LED x 8 //////////
	LED,

	//////// BUTTON x 4, EXT_IO and CPU_RESET_n //////////
	BUTTON,
	CPU_RESET_n,
	EXT_IO,

	//////// DIP SWITCH x 8 //////////
	SW,

	//////// SLIDE SWITCH x 4 //////////
	SLIDE_SW,

	//////// SEG7 //////////
	SEG0_D,
	SEG0_DP,
	SEG1_D,
	SEG1_DP,

	//////// Fan //////////
	FAN_CTRL,

	//////// HSMC-A //////////
	AD_SCLK,
	AD_SDIO,
	ADA_D,
	ADA_DCO,
	ADA_OE,
	ADA_OR,
	ADA_SPI_CS,
	ADB_D,
	ADB_DCO,
	ADB_OE,
	ADB_OR,
	ADB_SPI_CS,
	AIC_BCLK,
	AIC_DIN,
	AIC_DOUT,
	AIC_LRCIN,
	AIC_LRCOUT,
	AIC_SPI_CS,
	AIC_XCLK,
	CLKIN1,
	CLKOUT0,
	DA,
	DB,
	FPGA_CLK_A_N,
	FPGA_CLK_A_P,
	FPGA_CLK_B_N,
	FPGA_CLK_B_P,
	J1_152,
	XT_IN_N,
	XT_IN_P,

	//////// HSMC I2C //////////
	HSMC_SCL,
	HSMC_SDA 
);

//=======================================================
//  PARAMETER declarations
//=======================================================
parameter	NSAMPLES		= 1170;			// Number of samples per A-line

//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input		          		GCLKIN;			// 50 kHz A-line (sweep) Trigger
output		          		GCLKOUT_FPGA;
input		          		OSC_50_BANK2;
input		          		OSC_50_BANK3;
input		          		OSC_50_BANK4;
input		          		OSC_50_BANK5;
input		          		OSC_50_BANK6;
input		          		OSC_50_BANK7;
input		          		PLL_CLKIN_p;

//////////// LED x 8 //////////
output		     [7:0]		LED;

//////////// BUTTON x 4, EXT_IO and CPU_RESET_n //////////
input		     [3:0]		BUTTON;
input		          		CPU_RESET_n;
inout		          		EXT_IO;

//////////// DIP SWITCH x 8 //////////
input		     [7:0]		SW;

//////////// SLIDE SWITCH x 4 //////////
input		     [3:0]		SLIDE_SW;

//////////// SEG7 //////////
output		     [6:0]		SEG0_D;
output		          		SEG0_DP;
output		     [6:0]		SEG1_D;
output		          		SEG1_DP;

//////////// Fan //////////
output		          		FAN_CTRL;

//////////// HSMC-A //////////
inout		          		AD_SCLK;
inout		          		AD_SDIO;
input		    [13:0]		ADA_D;
input		          		ADA_DCO;
output		          		ADA_OE;
input		          		ADA_OR;
output		          		ADA_SPI_CS;
input		    [13:0]		ADB_D;
input		          		ADB_DCO;
output		          		ADB_OE;
input		          		ADB_OR;
output		          		ADB_SPI_CS;
inout		          		AIC_BCLK;
output		          		AIC_DIN;
input		          		AIC_DOUT;
inout		          		AIC_LRCIN;
inout		          		AIC_LRCOUT;
output		          		AIC_SPI_CS;
output		          		AIC_XCLK;
input		          		CLKIN1;
output		          		CLKOUT0;
output		    [13:0]		DA;
output		    [13:0]		DB;
inout		          		FPGA_CLK_A_N;
inout		          		FPGA_CLK_A_P;
inout		          		FPGA_CLK_B_N;
inout		          		FPGA_CLK_B_P;
inout		          		J1_152;
input		          		XT_IN_N;
input		          		XT_IN_P;

//////////// HSMC I2C //////////
output		          		HSMC_SCL;
inout		          		HSMC_SDA;


//=======================================================
//  REG/WIRE declarations
//=======================================================
wire						reset_n;
wire						sys_clk;
wire						sys_clk_90deg;
wire						sys_clk_180deg;
wire						sys_clk_270deg;
wire						pll_locked;

wire		[12:0]			i_sine1;
wire		[12:0]			i_sine10;
wire		[12:12]			t_sine1;
wire		[12:12]			t_sine10;
reg			[12:0]			is_sine1;
reg			[12:0]			is_sine10;
reg			[12:0]			iu_sine1;
reg			[12:0]			iu_sine10;

wire		[13:0]			o_sine;
reg			[13:0]			o_sine_p;
reg			[13:0]			o_sine_n;

reg			[13:0]			per_a2da_d;
reg			[13:0]			per_a2db_d;
reg			[13:0]			a2da_data;
reg			[13:0]			a2db_data;

wire		[13:0]			fir_in_data;
wire		[13:0]			fir_data;

wire						heartbeat;

reg 		[13:0] 			A_line 			[0:NSAMPLES-1];  
// The above describes an A-line of 1170 Elements, each 14 bits wide 



//=======================================================
//  Structural coding
//=======================================================
//--- globa signal assign
assign	reset_n			= CPU_RESET_n;

assign	FAN_CTRL		= 1'bz;

assign	FPGA_CLK_A_P	=  sys_clk_180deg;
assign	FPGA_CLK_A_N	= ~sys_clk_180deg;
assign	FPGA_CLK_B_P	=  sys_clk_270deg;
assign	FPGA_CLK_B_N	= ~sys_clk_270deg;

// Assign for indicators
assign	LED[0]			= ~pll_locked;		// pll locked
assign	LED[1]			= ~SLIDE_SW[0];		// (DFS)Data Format Select indicator
assign	LED[2]			= ~SLIDE_SW[1];		// (DCS)Duty Cycle Stabilizer Select indicator
assign	LED[3]			= !SLIDE_SW[3] ? ~ADA_OR : ~ADB_OR;	// Out-of-Range indicator
assign	LED[4]			= BUTTON[0];		// reset 1MHz NCO output indicator
assign	LED[5]			= BUTTON[1];		// reset 10MHz NCO output indicator
assign	LED[6] 			= ~SLIDE_SW[3];		// channel A or B indicator
assign	heartbeat		= count[15];		// heartbeat (bit15)
assign	LED[7] 			= heartbeat;		// heartbeat wire

// assign for ADC control signal
assign	AD_SCLK			= SLIDE_SW[0];		// (DFS)Data Format Select
assign	AD_SDIO			= SLIDE_SW[1];		// (DCS)Duty Cycle Stabilizer Select
assign	ADA_OE			= 1'b0;				// enable ADA output
assign	ADA_SPI_CS		= 1'b1;				// disable ADA_SPI_CS (CSB)
assign	ADB_OE			= 1'b0;				// enable ADB output
assign	ADB_SPI_CS		= 1'b1;				// disable ADB_SPI_CS (CSB)

// assign for DAC output data
assign	DA = o_sine_p;
assign 	DB 				= a2da_data;		// Map ADC channel A to DAC channel B

// 7 Segment Display dot
assign	SEG0_DP 		= ~heartbeat;		// LED[7] inverted
assign	SEG1_DP 		= 1'b1;				// Segment 1 dot OFF = 1

// 7 segment module 0 (faster count)
SevenSegmentDisplayDecoder SevenSegmentDisplayDecoder_inst(SEG0_D, count[18:15]);

// 7 segment module 1 (slower count)
SevenSegmentDisplayDecoder(SEG1_D, count[22:19]);


//--- pll
pll		pll_inst(
			.inclk0(OSC_50_BANK6),
			.c0(sys_clk),
			.c1(sys_clk_90deg),
			.c2(sys_clk_180deg),
			.c3(sys_clk_270deg),
			.locked(pll_locked)
			);

//--- NCO function 1.001MHz
NCO_1MHz	NCO_1MHz_inst(
			.phi_inc_i(32'd42992623),
			.clk(sys_clk),
			.reset_n(BUTTON[0]),
			.clken(1'b1),
			.fsin_o(i_sine1),
			.out_valid()
			);

//--- NCO function 10.01MHz
NCO_10MHz	NCO_10MHz_inst(
			.phi_inc_i(32'd429926226),
			.clk(sys_clk),
			.reset_n(BUTTON[1]),
			.clken(1'b1),
			.fsin_o(i_sine10),
			.out_valid()
			);

always @(negedge reset_n or posedge sys_clk)
begin
	if (!reset_n) begin
		is_sine1	<= 13'd0;
		is_sine10	<= 13'd0;
		iu_sine1	<= 13'd0;
		iu_sine10	<= 13'd0;
	end
	else begin
		is_sine1	<= i_sine1;
		is_sine10	<= i_sine10;
		iu_sine1	<= {~is_sine1[12],is_sine1[11:0]};
		iu_sine10	<= {~is_sine10[12],is_sine10[11:0]};
	end
end

//--- Sum of the two signals
//add		add_inst(
//			.dataa({1'b1,iu_sine1}),
//			.datab({1'b1,iu_sine10}),
//			.result(o_sine)
//			);

// Only assign 10 MHz sign to DAC
//add		add_inst(
//			constant_DC,
//			.datab({1'b1,iu_sine10}),
//			.result(o_sine)
//			);
assign o_sine = iu_sine10;

always @(negedge reset_n or posedge sys_clk)
begin
	if (!reset_n) begin
		o_sine_p	<= 14'd0;
		o_sine_n	<= 14'd0;
	end
	else begin
		o_sine_p	<= o_sine;
		o_sine_n	<= ~o_sine_p;
	end
end


//--- analog to digital converter capture and sync
	//--- Channel A
always @(negedge reset_n or posedge ADA_DCO)
begin
	if (!reset_n) begin
		per_a2da_d	<= 14'd0;
	end
	else begin
		per_a2da_d	<= ADA_D;
	end
end

always @(negedge reset_n or posedge sys_clk)
begin
	if (!reset_n) begin
		a2da_data	<= 14'd0;
	end
	else begin
		a2da_data	<= per_a2da_d;
	end
end

	//--- Channel B
always @(negedge reset_n or posedge ADB_DCO)
begin
	if (!reset_n) begin
		per_a2db_d	<= 14'd0;
	end
	else begin
		per_a2db_d	<= ADB_D;
	end
end

always @(negedge reset_n or posedge sys_clk)
begin
	if (!reset_n) begin
		a2db_data	<= 14'd0;
	end
	else begin
		a2db_data	<= per_a2db_d;
	end
end


//--- 3 MHz low pass FIR filter
assign	fir_in_data	= !SLIDE_SW[3] ?  a2da_data : a2db_data;

FIR_3MHz_low	FIR_3MHz_low_inst (
			.clk(sys_clk),
			.reset_n(reset_n),
			.ast_sink_data(fir_in_data),
			.ast_sink_valid(1'b1),
			.ast_source_ready(1'b1),
			.ast_sink_error(2'b00),
			.ast_source_data(fir_data),
			.ast_sink_ready(),
			.ast_source_valid(),
			.ast_source_error()
			);


//--- count for Heartbeat
reg		[31:0]				count;
always @(negedge reset_n or posedge GCLKIN)
// 50 kHz A-line (sweep) Trigger
begin
	if (!reset_n) begin
		count	<= 0;
	end
	else begin
		count	<= count + 1'b1;
	end
end


//--- probe points for data capture
sine_1		sin1_inst(
			.probe(iu_sine1),
			.source());

sine_10		sin10_inst(
			.probe(iu_sine10),
			.source());

p_sine		p_sine_inst(
			.probe(o_sine_p),
			.source());

a2d_data_a	a2d_data_a_inst(
			.probe(a2da_data),
			.source());

a2d_data_b	a2d_data_b_inst(
			.probe(a2db_data),
			.source());

fir_out		fir_out_inst(
			.probe(fir_data),
			.source());

endmodule